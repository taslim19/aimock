{% extends "base.html" %}

{% block title %}Interview - AI Mock Interview System{% endblock %}

{% block extra_css %}
<style>
    .interview-progress {
        margin-bottom: 20px;
    }
    .progress-bar {
        width: 100%;
        height: 10px;
        background: #e0e0e0;
        border-radius: 5px;
        overflow: hidden;
    }
    .progress-fill {
        height: 100%;
        background: #4CAF50;
        transition: width 0.3s;
    }
</style>
{% endblock %}

{% block content %}
<div class="interview-container">
    <div class="container">
        <div class="interview-header">
            <h1>{{ interview.domain }} Interview</h1>
            <div class="interview-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <p id="progressText">Question 0 of {{ questions|length }}</p>
            </div>
        </div>

        <div id="questionContainer" class="question-container">
            <!-- Questions will be loaded here -->
        </div>

        <div id="evaluationContainer" class="evaluation-container" style="display: none;">
            <!-- Evaluation results will be shown here -->
        </div>

        <div class="interview-actions">
            <button id="nextQuestionBtn" class="btn btn-primary" style="display: none;">Next Question</button>
            <button id="completeInterviewBtn" class="btn btn-success" style="display: none;">Complete Interview</button>
        </div>
    </div>
</div>

<script>
const interviewId = {{ interview.id }};
const questions = {{ questions|tojson }};
let currentQuestionIndex = 0;
let answeredQuestions = 0;
let recognition = null;
let isRecording = false;
let confirmedText = '';  // Text that has been confirmed (final results)
let lastResultLength = 0;  // Track how many results we've processed

// Initialize Web Speech API
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'en-US';
    
    recognition.onresult = function(event) {
        const answerTextarea = document.getElementById('answerText');
        if (!answerTextarea) return;
        
        // Process only NEW results (from lastResultLength onwards)
        let newFinalText = '';
        let latestInterim = '';
        
        // Process results starting from where we left off
        for (let i = lastResultLength; i < event.results.length; i++) {
            const result = event.results[i];
            const transcript = result[0].transcript.trim();
            
            if (result.isFinal) {
                // Only add final text if it's new
                if (transcript && !confirmedText.includes(transcript)) {
                    newFinalText += transcript + ' ';
                    confirmedText += transcript + ' ';
                }
            } else {
                // Get latest interim result
                if (i >= event.resultIndex) {
                    latestInterim = transcript;
                }
            }
        }
        
        // Update lastResultLength to track what we've processed
        lastResultLength = event.results.length;
        
        // Build the display text
        let displayText = confirmedText.trim();
        
        // Add new final text
        if (newFinalText.trim()) {
            displayText = (displayText + ' ' + newFinalText.trim()).trim();
        }
        
        // Add interim text if no new final text
        if (latestInterim && !newFinalText.trim()) {
            // Remove any previous interim text from display
            displayText = displayText.replace(/\s*\[interim\]\s*$/, '');
            answerTextarea.value = displayText + (displayText ? ' ' : '') + latestInterim + ' [interim]';
        } else {
            // Show confirmed text only
            answerTextarea.value = displayText;
        }
    };
    
    recognition.onerror = function(event) {
        console.error('Speech recognition error:', event.error, event);
        const statusEl = document.getElementById('recordingStatus');
        
        // Handle specific error types
        if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
            if (statusEl) {
                statusEl.textContent = '‚ùå Microphone blocked - Allow in browser settings';
                statusEl.style.color = '#e74c3c';
            }
            alert('Microphone access denied!\n\nPlease:\n1. Click the lock icon (üîí) in address bar\n2. Allow Microphone\n3. Refresh page');
            stopRecording();
            return;
        }
        
        if (statusEl) {
            statusEl.textContent = 'Error: ' + event.error;
            statusEl.style.color = '#e74c3c';
        }
        
        // Don't auto-stop on certain errors
        if (event.error === 'no-speech') {
            // No speech detected, but keep trying
            return;
        }
        
        if (event.error === 'audio-capture') {
            // Audio capture issue - might be permission
            if (statusEl) {
                statusEl.textContent = '‚ö†Ô∏è Check microphone connection';
            }
            return;
        }
        
        stopRecording();
    };
    
    recognition.onstart = function() {
        console.log('Speech recognition started');
    };
    
    recognition.onend = function() {
        if (isRecording) {
            // Auto-restart if still recording
            try {
                recognition.start();
            } catch (e) {
                stopRecording();
            }
        }
    };
} else {
    console.warn('Speech recognition not supported in this browser');
}

function loadQuestion() {
    if (currentQuestionIndex >= questions.length) {
        showCompleteButton();
        return;
    }

    const question = questions[currentQuestionIndex];
    const container = document.getElementById('questionContainer');
    
    container.innerHTML = `
        <div class="question-card">
            <div class="question-header">
                <h2>Question ${currentQuestionIndex + 1}</h2>
                <span class="question-type">${question.question_type || 'General'}</span>
            </div>
            <div class="question-text">
                <p>${question.question_text}</p>
            </div>
            <div class="answer-section">
                <label for="answerText">Your Answer:</label>
                <div class="answer-input-wrapper">
                    <textarea id="answerText" rows="8" placeholder="Type your answer here or use voice input..."></textarea>
                    <div class="voice-controls">
                        <button id="startRecordingBtn" class="btn btn-secondary btn-voice" title="Start Voice Input">
                            üé§ Start Recording
                        </button>
                        <button id="stopRecordingBtn" class="btn btn-secondary btn-voice" style="display: none;" title="Stop Recording">
                            ‚èπÔ∏è Stop Recording
                        </button>
                        <span id="recordingStatus" class="recording-status"></span>
                    </div>
                </div>
            </div>
            <button id="submitAnswerBtn" class="btn btn-primary">Submit Answer</button>
        </div>
    `;

    document.getElementById('submitAnswerBtn').addEventListener('click', submitAnswer);
    
    // Voice input handlers - always attach, function will handle unsupported browsers
    const startBtn = document.getElementById('startRecordingBtn');
    const stopBtn = document.getElementById('stopRecordingBtn');
    
    if (startBtn) {
        startBtn.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Start recording button clicked');
            startRecording();
        };
        console.log('Start button event listener attached');
    } else {
        console.error('Start recording button not found!');
    }
    
    if (stopBtn) {
        stopBtn.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Stop recording button clicked');
            stopRecording();
        };
    }
    
    // Hide voice controls if not supported
    if (!recognition) {
        console.warn('Speech recognition not available');
        const voiceControls = document.querySelector('.voice-controls');
        if (voiceControls) {
            voiceControls.style.display = 'none';
        }
    } else {
        console.log('Speech recognition initialized successfully');
    }
    
    updateProgress();
}

function startRecording() {
    console.log('startRecording called, recognition:', recognition, 'isRecording:', isRecording);
    
    if (!recognition) {
        alert('Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
        return;
    }
    
    if (isRecording) {
        console.log('Already recording, stopping first');
        stopRecording();
        setTimeout(startRecording, 500);
        return;
    }
    
    // Reset tracking when starting new recording
    confirmedText = '';
    lastResultLength = 0;
    
    try {
        console.log('Starting speech recognition...');
        recognition.start();
        isRecording = true;
        
        const startBtn = document.getElementById('startRecordingBtn');
        const stopBtn = document.getElementById('stopRecordingBtn');
        const statusEl = document.getElementById('recordingStatus');
        
        if (startBtn) {
            startBtn.style.display = 'none';
            console.log('Start button hidden');
        }
        if (stopBtn) {
            stopBtn.style.display = 'inline-block';
            console.log('Stop button shown');
        }
        if (statusEl) {
            statusEl.textContent = 'üî¥ Recording...';
            statusEl.style.color = '#e74c3c';
            console.log('Status updated to recording');
        }
    } catch (e) {
        console.error('Error starting recognition:', e);
        isRecording = false;
        
        if (e.name === 'InvalidStateError') {
            alert('Recording is already active. Please stop it first.');
        } else if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
            const helpMsg = 'Microphone access is blocked!\n\n' +
                'To enable:\n' +
                '1. Click the lock icon (üîí) in your browser address bar\n' +
                '2. Find "Microphone" and change to "Allow"\n' +
                '3. Or go to browser Settings ‚Üí Privacy ‚Üí Site Settings ‚Üí Microphone\n' +
                '4. Refresh this page and try again';
            alert(helpMsg);
            
            // Update status
            const statusEl = document.getElementById('recordingStatus');
            if (statusEl) {
                statusEl.textContent = '‚ùå Microphone blocked - Check browser settings';
                statusEl.style.color = '#e74c3c';
            }
        } else {
            alert('Could not start voice recording: ' + e.message + '\n\nError: ' + e.name);
        }
    }
}

function stopRecording() {
    console.log('stopRecording called, isRecording:', isRecording);
    if (recognition && isRecording) {
        try {
            recognition.stop();
            console.log('Recognition stopped');
        } catch (e) {
            console.error('Error stopping recognition:', e);
        }
        isRecording = false;
        confirmedText = ''; // Reset tracking
        lastResultLength = 0;
        
        // Clean up any interim markers in the text
        const answerTextarea = document.getElementById('answerText');
        if (answerTextarea) {
            answerTextarea.value = answerTextarea.value.replace(/\s*\[interim\]\s*$/, '');
        }
        
        const startBtn = document.getElementById('startRecordingBtn');
        const stopBtn = document.getElementById('stopRecordingBtn');
        const statusEl = document.getElementById('recordingStatus');
        
        if (startBtn) {
            startBtn.style.display = 'inline-block';
            console.log('Start button shown');
        }
        if (stopBtn) {
            stopBtn.style.display = 'none';
            console.log('Stop button hidden');
        }
        if (statusEl) {
            statusEl.textContent = 'Recording stopped';
            statusEl.style.color = '#27ae60';
            setTimeout(() => {
                statusEl.textContent = '';
            }, 2000);
        }
    }
}

function updateProgress() {
    const progress = ((currentQuestionIndex) / questions.length) * 100;
    document.getElementById('progressFill').style.width = progress + '%';
    document.getElementById('progressText').textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
}

async function submitAnswer() {
    const answerText = document.getElementById('answerText').value.trim();
    
    if (!answerText) {
        alert('Please provide an answer before submitting.');
        return;
    }

    const submitBtn = document.getElementById('submitAnswerBtn');
    submitBtn.disabled = true;
    submitBtn.textContent = 'Evaluating...';

    try {
        const response = await fetch('/submit-answer', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                question_id: questions[currentQuestionIndex].id,
                answer_text: answerText
            })
        });

        const data = await response.json();
        
        if (data.success) {
            showEvaluation(data.evaluation);
            answeredQuestions++;
            
            if (currentQuestionIndex < questions.length - 1) {
                document.getElementById('nextQuestionBtn').style.display = 'block';
            } else {
                showCompleteButton();
            }
        } else {
            alert('Error submitting answer: ' + data.message);
            submitBtn.disabled = false;
            submitBtn.textContent = 'Submit Answer';
        }
    } catch (error) {
        alert('An error occurred. Please try again.');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Answer';
    }
}

function showEvaluation(evaluation) {
    const container = document.getElementById('evaluationContainer');
    container.style.display = 'block';
    container.innerHTML = `
        <div class="evaluation-card">
            <h3>Evaluation Results</h3>
            <div class="scores-grid">
                <div class="score-item">
                    <label>Clarity</label>
                    <div class="score-value">${evaluation.clarity}%</div>
                </div>
                <div class="score-item">
                    <label>Accuracy</label>
                    <div class="score-value">${evaluation.accuracy}%</div>
                </div>
                <div class="score-item">
                    <label>Communication</label>
                    <div class="score-value">${evaluation.communication}%</div>
                </div>
                <div class="score-item">
                    <label>Confidence</label>
                    <div class="score-value">${evaluation.confidence}%</div>
                </div>
                <div class="score-item overall">
                    <label>Overall Score</label>
                    <div class="score-value">${evaluation.overall}%</div>
                </div>
            </div>
            <div class="feedback-section">
                <h4>Feedback</h4>
                <p>${evaluation.feedback}</p>
            </div>
            <div class="strengths-improvements">
                <div class="strengths">
                    <h4>Strengths</h4>
                    <ul>
                        ${evaluation.strengths.map(s => `<li>${s}</li>`).join('')}
                    </ul>
                </div>
                <div class="improvements">
                    <h4>Areas for Improvement</h4>
                    <ul>
                        ${evaluation.improvements.map(i => `<li>${i}</li>`).join('')}
                    </ul>
                </div>
            </div>
        </div>
    `;
}

function showCompleteButton() {
    document.getElementById('completeInterviewBtn').style.display = 'block';
    document.getElementById('nextQuestionBtn').style.display = 'none';
}

document.getElementById('nextQuestionBtn').addEventListener('click', function() {
    // Stop recording if active
    if (isRecording) {
        stopRecording();
    }
    currentQuestionIndex++;
    document.getElementById('evaluationContainer').style.display = 'none';
    document.getElementById('nextQuestionBtn').style.display = 'none';
    loadQuestion();
});

document.getElementById('completeInterviewBtn').addEventListener('click', async function() {
    if (answeredQuestions < questions.length) {
        if (!confirm('You haven\'t answered all questions. Complete interview anyway?')) {
            return;
        }
    }

    const btn = this;
    btn.disabled = true;
    btn.textContent = 'Completing...';

    try {
        const response = await fetch(`/complete-interview/${interviewId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        const data = await response.json();
        
        if (data.success) {
            window.location.href = data.redirect;
        } else {
            alert('Error completing interview: ' + data.message);
            btn.disabled = false;
            btn.textContent = 'Complete Interview';
        }
    } catch (error) {
        alert('An error occurred. Please try again.');
        btn.disabled = false;
        btn.textContent = 'Complete Interview';
    }
});

// Load first question
loadQuestion();
</script>
{% endblock %}

